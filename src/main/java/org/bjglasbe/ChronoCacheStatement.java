package org.bjglasbe;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.sql.SQLException;
import java.sql.SQLWarning;

public class ChronoCacheStatement implements Statement {

    private ChronoCacheConnection conn;

    public ChronoCacheStatement( ChronoCacheConnection conn ) {
        this.conn = conn;
    }

    @Override
    public void addBatch( String sql ) {
        // TODO We could actually support this
        throw new UnsupportedOperationException();
    }

    @Override
    public void cancel() {
    }

    @Override
    public void clearBatch() {
        throw new UnsupportedOperationException();
    }

    @Override
    public void clearWarnings() {
    }

    @Override
    public void close() {
    }

    @Override
    public void closeOnCompletion() {
    }

    @Override
    public boolean execute( String sql ) {
        //conn.sendquery()
        // Return true if we have a result set, false otherwise
        return true;
    }

    // We don't deal with autogenerated keys right now.
    @Override
    public boolean execute( String sql, int autoGeneratedKeys ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean execute( String sql, int[] columnIndexes ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean execute( String sql, String[] columnNames ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int[] executeBatch() {
        throw new UnsupportedOperationException();
    }

    @Override
    public ResultSet executeQuery( String sql ) {
        //conn.send()...
        return null;
    }

    @Override
    public int executeUpdate( String sql ) {
        //conn.send()...
        return -1;
    }

    @Override
    public int executeUpdate( String sql, int autoGeneratedKeys ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int executeUpdate( String sql, String[] columnNames ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public Connection getConnection() {
        return conn;
    }

    @Override
    public int getFetchDirection() {
        // We return everything anyways
        return ResultSet.FETCH_FORWARD;
    }

    @Override
    public int getFetchSize() {
        // Return everything?
        return 0;
    }
    @Override
    public ResultSet getGeneratedKeys() {
        throw new UnsupportedOperationException();
    }

    @Override
    public int getMaxFieldSize() {
        return 0;
    }

    @Override
    public int getMaxRows() {
        return 0;
    }

    @Override
    public boolean getMoreResults() {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean getMoreResults(int current) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int getQueryTimeout() {
        return 0;
    }
    @Override
    public ResultSet getResultSet() {
        // FIXME: return result set, if any
        return null;
    }

    @Override
    public int getResultSetConcurrency() {
        return ResultSet.CONCUR_READ_ONLY;
    }

    @Override
    public int getResultSetHoldability() {
        return ResultSet.HOLD_CURSORS_OVER_COMMIT;
    }

    @Override
    public int getResultSetType() {
        return ResultSet.TYPE_FORWARD_ONLY;
    }

    @Override
    public int getUpdateCount() {
        //FIXME: update count, if any
        return -1;
    }

    @Override
    public SQLWarning getWarnings(){
        //SQLWarning?
        return null;
    }

    @Override
    public boolean isClosed() {
        //FIXME
        return false;
    }

    @Override
    public boolean isCloseOnCompletion() {
        return false;
    }

    @Override
    public boolean isPoolable() {
        return false;
    }

    @Override
    public void setCursorName( String name ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setEscapeProcessing( boolean enable ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setFetchDirection( int direction ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setFetchSize( int rows ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setMaxFieldSize( int max ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setMaxRows( int max ) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void setPoolable( boolean poolable ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setQueryTimeout( int seconds ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public <T> T unwrap(Class<T> iface ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean isWrapperFor( Class<?> iface ) throws SQLException {
        return false;
    }

}
