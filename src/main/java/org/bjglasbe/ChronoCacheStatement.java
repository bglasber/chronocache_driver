package org.bjglasbe;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.sql.SQLException;
import java.sql.SQLWarning;

public class ChronoCacheStatement implements Statement {

    private ChronoCacheConnection conn;
    private ResultSet lastResultSet;
    private int lastQueryVal;

    public ChronoCacheStatement( ChronoCacheConnection conn ) {
        this.conn = conn;
        lastResultSet = null;
        lastQueryVal = -1;
    }

    @Override
    public void addBatch( String sql ) {
        // TODO We could actually support this
        throw new UnsupportedOperationException();
    }


    @Override
    public void cancel() {
    }

    @Override
    public void clearBatch() {
        throw new UnsupportedOperationException();
    }

    @Override
    public void clearWarnings() {
    }

    @Override
    public void close() {
    }

    @Override
    public void closeOnCompletion() {
    }

    private boolean isReadOnlyQuery( String sql ) {
        return sql.startsWith( "SELECT" );
    }

    private void stashLastQueryResultSet( ResultSet rs ) {
        this.lastResultSet = rs;
        this.lastQueryVal = -1;
    }

    private void stashLastUpdateResult( int val ) {
        this.lastResultSet = null;
        this.lastQueryVal = val;
    }

    @Override
    public boolean execute( String sql ) throws SQLException {
        if( isReadOnlyQuery( sql ) ) {
            ResultSet rs = conn.restReadQuery( sql, 0 );
            stashLastQueryResultSet( rs );
            return true;
        }
        int val = conn.restOtherQuery( sql, 0 );
        stashLastUpdateResult( val );
        
        return false;
    }

    // We don't deal with autogenerated keys right now.
    @Override
    public boolean execute( String sql, int autoGeneratedKeys ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean execute( String sql, int[] columnIndexes ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean execute( String sql, String[] columnNames ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int[] executeBatch() {
        throw new UnsupportedOperationException();
    }

    @Override
    public ResultSet executeQuery( String sql ) throws SQLException {
        ResultSet rs = conn.restReadQuery( sql, 0 );
        return rs;
    }

    @Override
    public int executeUpdate( String sql ) throws SQLException {
        int val = conn.restOtherQuery( sql, 0 ); 
        return val;
    }

    @Override
    public int executeUpdate( String sql, int autoGeneratedKeys ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int executeUpdate( String sql, String[] columnNames ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public Connection getConnection() {
        return conn;
    }

    @Override
    public int getFetchDirection() {
        // We return everything anyways
        return ResultSet.FETCH_FORWARD;
    }

    @Override
    public int getFetchSize() {
        // Return everything?
        return 0;
    }
    @Override
    public ResultSet getGeneratedKeys() {
        throw new UnsupportedOperationException();
    }

    @Override
    public int getMaxFieldSize() {
        return 0;
    }

    @Override
    public int getMaxRows() {
        return 0;
    }

    @Override
    public boolean getMoreResults() {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean getMoreResults(int current) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int getQueryTimeout() {
        return 0;
    }
    @Override
    public ResultSet getResultSet() {
        // FIXME: return result set, if any
        return null;
    }

    @Override
    public int getResultSetConcurrency() {
        return ResultSet.CONCUR_READ_ONLY;
    }

    @Override
    public int getResultSetHoldability() {
        return ResultSet.HOLD_CURSORS_OVER_COMMIT;
    }

    @Override
    public int getResultSetType() {
        return ResultSet.TYPE_FORWARD_ONLY;
    }

    @Override
    public int getUpdateCount() {
        //FIXME: update count, if any
        return -1;
    }

    @Override
    public SQLWarning getWarnings(){
        //SQLWarning?
        return null;
    }

    @Override
    public boolean isClosed() {
        //FIXME
        return false;
    }

    @Override
    public boolean isCloseOnCompletion() {
        return false;
    }

    @Override
    public boolean isPoolable() {
        return false;
    }

    @Override
    public void setCursorName( String name ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setEscapeProcessing( boolean enable ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setFetchDirection( int direction ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setFetchSize( int rows ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setMaxFieldSize( int max ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setMaxRows( int max ) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void setPoolable( boolean poolable ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setQueryTimeout( int seconds ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public <T> T unwrap(Class<T> iface ) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean isWrapperFor( Class<?> iface ) throws SQLException {
        return false;
    }

}
